---
title: Normalization of Databases
author: Michael Fuchs
date: '2021-05-16'
slug: normalization-of-databases
categories: []
tags: []
output:
  blogdown::html_page:
    toc: true
    toc_depth: 5
---



# 1 Introduction

After I have already reported on [how to set up databases](https://michael-fuchs-sql.netlify.app/2021/03/07/create-a-database/), we now come to a very important topic that is related to this: What should I consider when setting up the data structure? 

So in this post, I want to cover **Database Normalization**.


# 2 Theoretical Background

## 2.1 What is Normalization in a Database?

Normalization is the process of reducing redundancy of data in the table and also improving data integrity. 
Normalization split a large table into smaller tables and define relationships between them to increases the clarity in organizing data.


## 2.2 Problems without Normalization

Normalization is necessary because without normalization in SQL many problems can occur. These can be, for example:

+ **Insertion Anomaly**: It occurs when we cannot insert data into the table without another attribute being present.
+ **Update Anomaly**: It is a data inconsistency that occurs due to data redundancy and partial update of data.
+ **Deletion Anomaly**: It occurs when certain attributes are lost due to deletion of other attributes.


## 2.3 Rules for Data Normalization

There are three main forms for Data Normalization: 

+ First Normal Form (1st NF)
+ Second Normal Form (2nd NF)
+ and Third Normal Form (3rd NF)


Normalization was developed by [IBM researcher E.F. Codd](https://history-computer.com/edgar-codd-creator-of-the-relational-database/) in the 1970s. In doing so, he established some rules for satisfying the normal forms.


**First Normal Form (1st NF)**

+ Same Data Type in a Column.
+ There are only Single Valued Attributes.
+ There is a Unique name for every Attribute/Column.
+ Uniquely identify a Row.


**Second Normal Form (2nd NF)**

+ Be in 1st NF.
+ The table should also not contain Partial Dependencies.


**Third Normal Form (3rd NF)**

+ Be in 2nd NF.
+ The table should also not contain Transitive Dependencies.




# 3 Database Normalisation

In the following I will give examples that show how to bring unnormalized data into the next Normal Form. 


## 3.1 First Normal Form (1st NF)


### 3.1.1 Same Data Type in a Column

In order to work with data within a column in a meaningful way, it is mandatory that these data correspond to the same data type. 

![](/post/2021-05-16-normalization-of-databases_files/p22p1.png)


### 3.1.2 There are only Single Valued Attributes

Likewise, unnecessary duplicate columns must be avoided.

![](/post/2021-05-16-normalization-of-databases_files/p22p2.png)


### 3.1.3 There is a Unique name for every Attribute/Column

All information in an observation should be available for query. If several values are stored within one cell, this could cause problems. 

![](/post/2021-05-16-normalization-of-databases_files/p22p3.png)


### 3.1.4 Uniquely identify a Row

Individual Observations must be identifiable. A good solution to the problem at hand would be to split the source table. 

![](/post/2021-05-16-normalization-of-databases_files/p22p4.png)


### 3.1.5 Digression: Primary Key vs. Foreign Key

In the previous example we saw the use of primary keys and a foreign key. But what are these keys actually and what do I need them for?



**A primary key** is used to ensure that the data in a particular column is unique. The primary key must not contain NULL values or repeating values, is limited to a single table, and is set to uniquely identify the corresponding rows of a table. This is either an existing table column or a column that is specially generated by the database according to a defined sequence.

**A foreign key** is a column or a group of columns in a relational database table that refers to the primary key of the other table. It is responsible for managing the relationship between the tables. The table that contains the foreign key is usually called the child table. The table whose primary key is referenced by the foreign key is usually called the parent table.


The use of Primary Keys and Foreign Keys also have a **protective function**. For example, in the example above, if we want to add another phone number to the StudentsPhone table and I make a mistake with the Student_ID (for example, if I want to use one that doesn't exist at all), I would get an insert error saying that this primary doesn't exist at all in the parent table.  




## 3.2 Second Normal Form (2nd NF)

Now that we know what the first normal form must look like, we come to the second normal form. 

Let's take a look at this sample table ('Sales_Table'):

![](/post/2021-05-16-normalization-of-databases_files/p22p5.png)


### 3.2.1 Digression: Composite Key

Is this table really in the first normal form? I don't see any primary key here at all... The answer is: **yes it is**. We do not have a primary key here, but a composite key. 

**What is a composite key?**

A composite key is a primary key composed of multiple columns used to identify a record uniquely. This table has a composite primary key Full_Name, Address.

With these two specifications, the lines can be clearly distinguished from each other, thus the first normal form is achieved. 



### 3.2.2 Add a Primary Key

Of course, it is better to work with primary keys. So in a first step I add this one.


![](/post/2021-05-16-normalization-of-databases_files/p22p6.png)


### 3.2.3 Digression: Candidate Key


So far so good. Let's take a closer look at the modified table and see what structure we have here:

![](/post/2021-05-16-normalization-of-databases_files/p22p7.png)

If we look at the Customer_ID and Product_ID columns we see that these are two candidate keys. 


**What is a candidate key?**

A candidate key is a set of attributes (or attribute) which uniquely identify the tuples in relation or table. Candidate key’s attributes can contain a NULL value which opposes to the primary key.



### 3.2.4 Split the Table

In **preparation to bring this table into the second normal form**, we should divide the table at this point to continue. 
This may look like the following:

![](/post/2021-05-16-normalization-of-databases_files/p22p8.png)




### 3.2.5 Partial Dependencies

As we know from the [rules for normalizing](https://michael-fuchs-sql.netlify.app/2021/05/16/normalization-of-databases/#rules-for-data-normalization) data the table **should not contain partial dependencies**.
Partial dependency means that a non-key attribute is functionally dependent on part of a composite key. 

Let's take a closer look at the Sales table that was created:

![](/post/2021-05-16-normalization-of-databases_files/p22p9.png)


Customer_ID and Product_ID again **result in a composite primary key**. The non-key attributes are Product_Name and Price.


In this case, Product_Name and Price only depends on Product_ID, which is **only part of the primary key**. Therefore, **this table does not satisfy the second Normal Form**.

To bring this table to Second Normal Form, we need to break the table into two parts again.


![](/post/2021-05-16-normalization-of-databases_files/p22p10.png)


Now there is no partial dependency anymore. 
For a complete view, I have included the Customer_Info_Table in the previously shown diagram. 




## 3.3 Third Normal Form (3rd NF)

Our two tables Sales_Table and Product_Table are now in the targeted normal form. Remains only the study of the remaining Customer_Info table. 


### 3.3.1 Transitive Dependencies

The [rule](https://michael-fuchs-sql.netlify.app/2021/05/16/normalization-of-databases/#rules-for-data-normalization) for achieving the third normal form states that the table **should also not contain transitive dependencies**.

Transitive dependency is nothing but, a non-prime attribute (other than candidate key) depending on another non-prime attribute which is entirely dependent on candidate key.



### 3.3.2 Remove Transitive Dependencies, Part I



Let's take a look at the Customer_Info table:

![](/post/2021-05-16-normalization-of-databases_files/p22p11.png)



**Address -> Full_Name**: 
Here, the Address attribute determines the Full_Name attribute. If you know the exact address, you can get the customers name. However, the customers name does not determine the address, because a customer can have multiple addresses. 



**Full_Name -> Nationality**:
Likewise, the Full_Name attribute determines the Nationality, but not the other way around, just because we know the nationality does not mean we can determine the name. 


But this table introduces a transitive dependency:

**Address - > Nationality**: 
If we know the address, we can determine the nationality via the Full_Name column.



To ensure 3rd NF, let's remove the transitive dependency. 
We can start by removing the Address column from the Customer_Info table and creating a separate Address table: 




![](/post/2021-05-16-normalization-of-databases_files/p22p12.png)


### 3.3.3 Remove Transitive Dependencies, Part II


Does this fix the problem? Let's examine our dependencies again:


#### 3.3.3.1 Address_Table

![](/post/2021-05-16-normalization-of-databases_files/p22p13.png)


**Address_ID -> Address**:
The Address depends on the Address_ID.

**No other dependencies** in this table exist, so we are okay. Note that the foreign key Customer_ID links this table to the Customer_Info table through its primary key Customer_ID. We have created a relationship to avoid a transitive dependency, a key design of relational databases.




#### 3.3.3.2 Customer_Info_Table

![](/post/2021-05-16-normalization-of-databases_files/p22p14.png)


**Customer_ID -> Full_Name**:
The Full_Name depends on the Customer_ID. 

**Full_Name -> Nationality**:
The nationality can be determined by the Full_Name attribute. 

**Customer_ID -> Nationality**:
The nationality can be determined from the Customer_ID through the Full_Name attribute. **We still have a transitive dependency**! 

We need to add a futher table to normalize this data:


![](/post/2021-05-16-normalization-of-databases_files/p22p15.png)


### 3.3.4 Wrap Up

Now we have created three tables in [this chapter](https://michael-fuchs-sql.netlify.app/2021/05/16/normalization-of-databases/#third-normal-form-3rd-nf), using foreign keys to link the tables together.


![](/post/2021-05-16-normalization-of-databases_files/p22p16.png)


+ The Address table’s foreign key Customer_ID links an address to a customer in the Customer_Info table.
+ The Customer_Info table’s foreign key Nationality_ID links a customer to a nationality in the Nationality table. 
+ The Nationality table has no foreign key because it has no need to link to another table in this design. 




### 3.3.5 Why Transitive Dependencies Are Bad Database Design


For this section we can look again at the origin table:

![](/post/2021-05-16-normalization-of-databases_files/p22p17.png)


If you delete the two customers 'Ben Smith' from Miami and 'Jill White', we will also automatically delete the nationality American from the database completely. 

You cannot add a new address to the database without adding a name as well. What would happen if you were provided with a free set of locations? You would not be able to use it until you have a customer that matches one of these addresses. 

If one of the customers changes their address (for example, due to a change of residence), you would need to go through all of that customer's orders and change the Address column. Having multiple records with the same customer can lead to inaccurate data. What if the person entering the data doesn't realize there are multiple records for him and changes the data in only one record?



The **benefits of removing transitive dependencies** are:

+ Amount of data duplication is reduced.
+ Data integrity achieved.



### 3.3.6 Final tables (in the third normal form)


Here again a short overview of all created tables in the third normal form:


![](/post/2021-05-16-normalization-of-databases_files/p22p18.png)


# 4 Conclusion

In this post I have explained what normalization of a database means and what rules exist for it. For all the rules I have listed examples that you can use to understand the meaning of the rules. 




